# Micro Kernal
[宏内核与微内核，Linux内核与Unix内核]("http://19831028.blog.51cto.com/1333653/390507/")

	单内核（Monolithic kernel）――单内核是个很大的进程。他的内部又能够被分为若干模块（或是层次或其他）。但是在运行的时候，他是个单独的二进制大映象。其模块间的通讯是通过直接调用其他模块中的函数实现的，而不是消息传递。
	单内核的支持者声称微内核的消息传递开销引起了效率的损失。微内核的支持者则认为因此而增加的内核设计的灵活性和可维护性能够弥补任何损失。
	
	微内核（Microkernel kernel）――在微内核中，大部分内核都作为单独的进程在特权状态下运行，他们通过消息传递进行通讯。在典型情况下，每个概念模块都有一个进程。因此，假如在设计中有一个系统调用模块，那么就必然有一个相应的进程来接收系统调用，并和能够执行系统调用的其他进程（或模块）通讯以完成所需任务。

[思考微内核--转载]("http://www.cnblogs.com/davidwang456/p/4462101.html")

	而对微内核来说，操作系统的大部分在内核之外，彼此间通过消息进行通信。换句话说，对于微内核来说，进程管理、内存管理、文件系统根本就不是微内核的一部分，这是一个看起来难以让人接受的结论，怎么能把操作系统内核的重要组成部分踢出去呢？请注意，我这里说的是，它们不是微内核的一部分，而不是说它们不是操作系统内核的一部分。有些让人糊涂，怎么又冒出一个内核。本着高内聚的原则，操作系统的实现让我们只需面对操作系统内核，而无需了解其内部实现。对于微内核的实现来说，其内部还会有一个内核，负责更加底层的内容，比如消息传递、中断管理、底层的进程管理等等，而我们作为用户所面对的内核不过是在这个内核之上构建起来的一个应用罢了。