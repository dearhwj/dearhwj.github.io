---
layout: post
title: 函数式编程
category: 开发
keywords: 
---

## 什么是函数式编程
我们的准则是，被称为“函数式”的函数或方法都只能修改本地变量。除此之外，它引用的 对象都应该是不可修改的对象。通过这种规定，我们期望所有的字段都为final类型，所有的引用类型字段都指向不可变对象。后续的内容中，你会看到我们实际也允许对方法中全新创建的对 象中的字段进行更新，不过这些字段对于其他对象都是不可见的，也不会因为保存对后续调用结 果造成影响


## 透明性
参考文档：[https://blog.csdn.net/lanchunhui/article/details/52473003](https://blog.csdn.net/lanchunhui/article/details/52473003)

1. 基础
初学程序设计时，比较容易混淆的两个概念是数学函数（math function）和程序中使用的函数。

在数学函数中 y=f(x)y=f(x)，一个输入值有固定的输出值。例如，无论计算多少次，sinπsin⁡π 的结果总是 0。如果 f(x)=x/2f(x)=x/2，那么 f(10)f(10) 无论计算 100 次还是 1000 次，其结果都是 5.

程序设计中的函数却不具备这种稳定的特性，因为函数的执行不仅依赖于输入值，而且会受到全局变量，输入文件，类的成员变量等诸多因素的影响。如下：

```
int counter = 0;
int count(){
    return ++counter;
}
```
此函数输入没有输入值，但每次都返回不同的结果。当然，就像数学函数那样，程序中函数还可以设计成“对同一输入值每次都返回相同结果”的形式。

函数的返回值只依赖于其输入值，这种特性就称为引用透明性（referential transparency）

2. 动态规划的缓存
显然，动态规划所使用的制表法（也即缓存）只能应用于具有引用透明性的函数。如果外在因素使相同输入值返回不同结果值，则不能缓存。

也即缓存对应的 map，实现的是同一个输入（key），同一个输出（value），而不可能出现同一个输入，可以得到不同的输出，也即输出结果的不确定性。

## 对递归和循环的思考
[原文地址](https://www.cnblogs.com/Leo_wl/p/3204489.html)

可以发现使用递归来实现程序，明显“简单”很多，而且符合人们直观的理解，而使用循环来实现程序很难一目了然的知道程序在做什么。这便是函数式编程的一大优势：是你在告诉程序要做什么，而不是告诉程序怎么去做。当然从内存占用和效率这个角度考虑，循环要比递归高效些。

那么为什么诸如阶乘这样的问题，人们的第一想法是用循环来考虑呢？这也许是最初学习编程的时候“先入为主”造成的，而且阶乘的递推关系不是十分直观，因为你要向一个不知道阶乘是何物的人解释什么是阶乘，恐怕不会使用递推关系来解释；返过来对斐波那契数列，就比较适合用递归关系来解释。

在实际的编程过程中我们很少用递归来解决问题，我想，一方面是受到传统过程式编程思维的影响，另一方面，大部分问题更容易用过程化的思维来思考。所以，我一直信奉“编程语言会影响人的思维方式，思维方式也会影响对语言的学习”。比如，我到现在都不是能很好的掌握javascript。于是我开始思考如何在两种思维间自如的切换呢？是否有通用的方法论呢？

现在尝试归纳上面的例子，并再试着举几个子：

1）斐波那契数列问题

循环实现，从1开始迭代，计算n-1和n-2，并迭代替换，直到n
递归实现，归纳出递推式f(n)=f(n-1)+f(n-2),当 n=0时为0，n=1时为1
2）阶乘问题

循环实现，从1开始迭代，并将迭代的结果乘法聚合，直到n
递归实现，归纳出递推式n!=n*(n-1)! 当n=0时，结果为1
3）求n以内正整数的和:1+2+3+…+n

循环实现，从1开始迭代，并将迭代的结果加法聚合，直到n
递归实现，归纳出递推式sum(n)=n+sum(n-1), 当n=1时为1
4）求两个数的最大公约数（Euclid算法）

循环实现，迭代计算a%b，将a替换为b，b替换为a%b，直到a%b=0
递归实现，如果a能整除b，那么b既是最大公约数，否则递推式gcd(a,b)=gcd(b,a%b)
5）数组倒置（这里不讨论首尾互换的特殊算法），1234567变成7654321

循环实现，从a[n]开始迭代，将结果聚合成新的数组，直到迭代到1
递归实现，归纳出递推式r(a[n])=r(a[n-1]) + a[1] 当n=0时为空，n=1时为a[1]
 

上面的问题都是很简单的问题，但是从中我们可以看到，两种思路的关键点：

循环的关键思路在于，进行迭代，直到满足某个条件，在迭代的过程中进行 迭代替换 或者聚合
递归的关键思路在于，归纳递推式，并且设置边界，以便递归结束
 

总结
到这里是本文想要阐述的所有内容。本文有感而发，随想而写，总结如下：递归和循环能够相互替代，递归代表的函数式编程倾向于”做什么”，而循环代表的过程式编程倾向于”怎么做”。两种方式对应着不同的程序设计思路，本文通过几个例子，简单总结了两种思路的不同之处以及关键点。希望对熟悉传统编程语言的人们掌握新兴的编程语言有所帮助。


## 递归与尾递归（Tail Recursion）


## 高阶函数

函数式编程的世界里，如果函数，比如Comparator.comparing，能满足下面任一要求就 可以被称为高阶函数(higher-order function):
* 接受至少一个函数作为参数 
* 返回的结果是一个函数


编写高阶函数或者方法时，你无法预知会接收什么样的参数——一旦传 入的参数有某些副作用，我们将会一筹莫展!如果作为参数传入的函数可能对你程序的状态产 生某些无法预期的改变，一旦发生问题，你将很难理解程序中发生了什么;它们甚至会用某种 难于调试的方式调用你的代码。因此，将所有你愿意接收的作为参数的函数可能带来的副作用 以文档的方式记录下来是一个不错的设计原则，最理想的情况下你接收的函数参数应该没有任 何副作用!


## 科里化

[原文地址](https://baike.baidu.com/item/%E6%9F%AF%E9%87%8C%E5%8C%96/10350525?fr=aladdin)

在计算机科学中，柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。这个技术由 Christopher Strachey 以逻辑学家 Haskell Curry 命名的，尽管它是 Moses Schnfinkel 和 Gottlob Frege 发明的。