---
layout: post
title: Java 7的新特性Fork/Join
category: JAVA
keywords: JAVA7
---
## 正文
分支/合并框架的目的是以递归方式将可以并行的任务拆分成更小的任务，然后将每个子任 务的结果合并起来生成整体结果。它是ExecutorService接口的一个实现，它把子任务分配给 线程池(称为ForkJoinPool)中的工作线程。首先来看看如何定义任务和子任务。


### 使用RecursiveTask
 要把任务提交到这个池，必须创建RecursiveTask<R>的一个子类，其中R是并行化任务(以 及所有子任务)产生的结果类型，或者如果任务不返回结果，则是RecursiveAction类型(当 然它可能会更新其他非局部机构)。要定义RecursiveTask，只需实现它唯一的抽象方法 compute:
 
    protected abstract R compute();
  这个方法同时定义了将任务拆分成子任务的逻辑，以及无法再拆分或不方便再拆分时，生成 单个子任务结果的逻辑。正由于此，这个方法的实现类似于下面的伪代码:
 
```
 if (任务足够小或不可分) { 顺序计算该任务
} else {
     将任务分成两个子任务
     递归调用本方法，拆分每个子任务，等待所有子任务完成
     合并每个子任务的结果
}
```
一般来说并没有确切的标准决定一个任务是否应该再拆分，但有几种试探方法可以帮助你做 出这一决定。我们会在7.2.1节中进一步澄清。递归的任务拆分过程如图7-3所示

![](imags/java7-fork-join.png)


## 代码

![](imags/java7-fork-join-code.png)


现在编写一个方法来并行对前n个自然数求和就很简单了。你只需把想要的数字数组传给 ForkJoinSumCalculator的构造函数:

```
public static long forkJoinSum(long n) {
long[] numbers = LongStream.rangeClosed(1, n).toArray(); ForkJoinTask<Long> task = new ForkJoinSumCalculator(numbers); return new ForkJoinPool().invoke(task);
}
```


## 使用分支/合并框架的最佳做法
  虽然分支/合并框架还算简单易用，不幸的是它也很容易被误用。以下是几个有效使用它的 最佳做法。 
  
1. 对一个任务调用join方法会阻塞调用方，直到该任务做出结果。因此，有必要在两个子任务的计算都开始之后再调用它。否则，你得到的版本会比原始的顺序算法更慢更复杂，因为每个子任务都必须等待另一个子任务完成才能启动。
2. 不应该在RecursiveTask内部使用ForkJoinPool的invoke方法。相反，你应该始终直接调用compute或fork方法，只有顺序代码才应该用invoke来启动并行计算。
3. 对子任务调用fork方法可以把它排进ForkJoinPool。同时对左边和右边的子任务调用它似乎很自然，但这样做的效率要比直接对其中一个调用compute低。这样做你可以为其中一个子任务重用同一线程，从而避免在线程池中多分配一个任务造成的开销。
4. 调试使用分支/合并框架的并行计算可能有点棘手。特别是你平常都在你喜欢的IDE里面 看栈跟踪(stack trace)来找问题，但放在分支合并计算上就不行了，因为调用compute的线程并不是概念上的调用方，后者是调用fork的那个。
5. 和并行流一样，你不应理所当然地认为在多核处理器上使用分支/合并框架就比顺序计算快。我们已经说过，一个任务可以分解成多个独立的子任务，才能让性能在并行化时 有所提升。所有这些子任务的运行时间都应该比分出新任务所花的时间长;一个惯用方 法是把输入/输出放在一个子任务里，计算放在另一个里，这样计算就可以和输入/输出 同时进行。此外，在比较同一算法的顺序和并行版本的性能时还有别的因素要考虑。就 像任何其他Java代码一样，分支/合并框架需要“预热”或者说要执行几遍才会被JIT编 译器优化。这就是为什么在测量性能之前跑几遍程序很重要，我们的测试框架就是这么 做的。同时还要知道，编译器内置的优化可能会为顺序版本带来一些优势(例如执行死 码分析——删去从未被使用的计算)。